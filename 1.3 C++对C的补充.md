>[info] # return

1. return在返回值时，假如你得到的值和你定义时的值类型不同，它会自动将你的值转换成你定义时的返回值。
2. 
3. 定义返回值是，如果是void（无返回值），也可以带return，但是不能接数值，直接分号结束，表示这个函数返回。
4. 
5. 如果函数的返回类型为void，函数体中可以有return，但不能带表达式或者值；
6. 如果函数的返回类型不是void，函数体中可以有多个return，但只能执行其中一个。


>[info]# 输入输出的基本操作

本应是按位左移,右移运算符,但在'iostream.h'头文件中被重载为基本数据类型数据的**插入运算符**和**提取运算符**.

cout>表达式1>>...>>表达式n;

一个cout语句可以分写在若干行或多个cout语句;cin类似.

~~~
cin>>a>>b>>c;
Cout<<a
    <<b
    <<c;
~~~

不能用一个插入运算符<<插入多个输出项.

~~~
cout<<a,b,c;    //error
~~~

在用cin输入时,系统会根据变量的类型从输入流中提取相应长度的字节.  注意:cin语句将跳过空格,回车,换行字符;而在C中将不被跳过,如用函数scanf,getchar.

C++中endl相当于C中的\\n起到换行的作用
>[info]# 输入输出流中的控制字符

**头文件：iomanip.h**

| 控制字符                     | 作用               |
| ---------------------------- | ------------------ |
| hex                          | 置基数为16         |
| oct                          | 置基数为8          |
| dec                          | 置基数为10         |
| setfill(c)                   | 填充字符c          |
| setprecision(n)              | 设置显示小数的精度 |
| setw                         | 设置域宽           |
| setiosflags(ios::fixed)      | 固定的浮点显示     |
| setiosflags(ios::scientific) | 指数表示           |
| setiosflags(ios::left)       | 左对齐             |
| setiosflags(ios::right)      | 右对齐             |
| setiosflags(ios::skipws)     | 忽略前导空白       |
| setiosflags(ios::uppercase)  | 16进制数大写输出   |
| setiosflags(ios::lowercase)  | 16进制数小写输出   |

**设置值的输出宽度**

- 除了使用空格来强行控制输出间隔外,还可以使用setw(n)控制符.
- 如果一个值需要比setw(n)确定的字符数更多的字符,则该值将使用它所需要的字符数.
- 如果一个值的字符数比setw(n)确定的字符个数要少,则在数字字符前显示空格.
- setw(n)仅仅影响下一个数值输出.
- setw(n)的默认值为宽度0,即setw(0).

**setprecision(n)的用法**

- 使用setprecision(n)可控制输出流显示浮点数的数字个数。C++默认的流输出数值有效位是6。
- 如果setprecision(n)与setiosflags(ios::fixed)合用，可以控制小数点右边的数字个数。setiosflags(ios::fixed)是用定点方式表示实数。
- 如果与setiosnags(ios::scientific)合用， 可以控制指数表示法的小数位数。setiosflags(ios::scientific)是用指数方式表示实数。
- setprecision(n)在C++中的最小有效个数是1。setprecision(0)相当于setprecision(1)。

## **例子**

```
/* ******控制字符浮点显示****** */
#include <iostream>
#include <iomanip>  //要用到格式控制符
using namespace std;

int main()
{
	double amount = 22.0/7;
	cout <<amount <<endl;
	cout <<setprecision(0) <<amount <<endl
		 <<setprecision(1) <<amount <<endl
		 <<setprecision(2) <<amount <<endl
		 <<setprecision(3) <<amount <<endl
		 <<setprecision(4) <<amount <<endl;
	cout <<setiosflags(ios::fixed);
    cout <<setprecision(8) <<amount <<endl;
    cout <<setiosflags(ios::scientific)     
    	 <<amount     
    	 <<endl;
      
    cout <<setprecision(6); //重新设置成原默认设置
      
    return 0;
}
```

```
/* ******使用填充字符****** */
#include <iostream>
#include <iomanip>
using namespace std; 
int main()
{
	cout <<setfill(’*’)       
		 <<setw(2) <<21 <<endl       
		 <<setw(3) <<21 <<endl       
		 <<setw(4) <<21 <<endl;  
	cout <<setfill(’ ’);  // 恢复默认设置  
	return 0;
}
```

```
/* ******左右对齐输出****** */
#include <iostream>
#include <iomanip>
using namespace std;
int main()
{
	cout <<setiosflags(ios::right)
		 <<setw(5) <<1
		 <<setw(5) <<2
		 <<setw(5) <<3 <<endl;
	cout <<setiosflags(ios::left)
		 <<setw(5) <<1
		 <<setw(5) <<2
		 <<setw(5) <<3 <<endl;
	return 0;
}
```

```
/* ******强制显示小数点****** */
#include <iostream>
#include <iomanip>
using namespace std; 
int main()
{
	cout <<10.0/5 <<endl;
	cout <<setiosflags(ios::showpoint)
		 <<10.0/5 <<endl;
	return 0;
}
```

```
/* ******强制显示符号位****** */
#include <iostream>
#include <iomanip>
using namespace std;
int main()
{  
	cout <<10 <<"  " <<-20 <<endl;  
	cout <<setiosflags(ios::showpos)
		 <<10 <<"  " <<-20 <<endl;
	return 0;
}
```

```
/* ******小数点对齐****** */
#include <iostream>
#include <iomanip>
using namespace std;
int main( )
{ 
	double a=123.456,b=3.14159,c=-3214.67; 
	cout<<setiosflags(ios∷fixed)
		<<setiosflags(ios∷right)
		<<setprecision(2);
	cout<<setw(10)<<a<<endl;
	cout<<setw(10)<<b<<endl;
	cout<<setw(10)<<c<<endl;
	return 0;
} 
```

>[info]# putchar和getchar

**(1). putchar函数(字符输出函数)**

函数原型:  int putchar(int);

调用格式:  putchar(c);

函数功能:  向标准输出设备(一般为显示器)输出一个字符,并返回输出字符的ASCII码值.

函数的参数c可以是字符常量,变量或整型变量.

**(2).getchar函数(字符输入函数)**

函数原型:  int getchar(void);

调用格式:  getchar( );

函数功能:  从输入设备(一般为键盘)上输入一个字符,函数的返回值是该字符的ASCII码.可以赋给字符变量或整型变量.

>[info]# 用const定义常变量

在定义变量时,如果加上关键字const,则变量的值在程序运行期间不能改变,这种变量称为常变量(constant variable).
            如 const int pi=3.1415926;
常量在定义时必须初始化,常量名不能放在赋值号的左边.
可以用常量表达式对常量进行初始化.

##  符号常量(#define)与const常量的区别

1. #define宏是在预处理阶段展开。
   const常量是编译运行阶段使用。

2. #define宏没有类型，不做任何类型检查，仅仅是展开。
   const常量有具体的类型，在编译阶段会执行类型检查。

3. #define宏仅仅是展开，有多少地方使用，就展开多少次，不会分配内存(宏定义不分配内存，**变量定义**分配内存。）
   const常量会在内存中分配(可以是堆中也可以是栈中)。

4. const常量可以进行调试的

    #define是不能进行调试的，因为在预编译阶段就已经替换掉了

5. const不足的地方，是与生俱来的，const不能重定义

    #define可以通过#undef取消某个符号的定义，再重新定义。

>[info]# 函数原型声明

所谓函数声明(declare),就是在函数尚在未定义的情况下,事先将该函数的有关信息通知编译系统,以便使编译能正常进行

函数返回类型    函数名（参数类型）；

```
#include <iostream>
using namespace std;
int main( )
{
	float add(float x,float y);              //对add函数作声明
    float a,b,c;
    cout<<”please enter a,b:”;
    cin>>a>>b;
    c=add(a,b);                                   //函数调用 cout<<”sum=”<<c<<endl; 		return 0;
}

float add(float x,float y)               //定义add函数
{
	float z;
    z=x+y;
    return (z);
}
```

>[info]# 内置函数

## **内联函数的需要性**

函数调用与返回时,都需要一定的时间和空间的开销;而通过关键字**inline**将一个函数声明成内联函数后,编译器会将该函数的调用处理成编译前的代码替换,而不是象普通函数在编译时的控制转移,从而提高了效率.

##  **内联函数的特点**

- 内联函数的代码必须在替换之前已经生成,所以内联函数必须在被调用之前声明或定义.
- 内联函数中,不能含有复杂的结构控制语句,如switch,while.

- 内联函数不能是递归函数.

- 内联函数只适合于只有1~5行的小函数.

## **内联函数与宏定义**

**宏定义**   

```
#define MAX(a,b) ((a)>(b)?(a):(b))
```

- 书写格式有过分的讲究,MAX与括号之间不能有空格,所有的参数都要加括号.
- 求值时会有副作用.
- 不作参数的类型检查.

**内联函数**可以有效解决上述问题,替代宏定义.

```
inline int MAX(int a,int b)
{
	return a>b?a:b;
}
```

## 例子

```
#include <iostream>
using namespace std;
inline int max(int,int, int);   //声明函数,注意左端有inline
int main( )
{
	int i=10,j=20,k=30,m;
    m=max(i,j,k);   //编译前被替换成:if (j>i) i=j;if(k>i) i=k;m=i;
	cout<<”max=”<<m<<endl;
    return 0;
}
inline int max(int a,int b,int c) //定义max为内置函数
{
	if(b>a) a=b;          //求a,b,c中的最大者
    if(c>a) a=c;
    return a;
}
```

>[info]# 函数的重载

## 重载的需要性

在不同类型上做类似运算而又用相同名字的情况称为**重载 (function overloading)**,即重新定义语义.

```
//重载前：
int abs(int);
long fbs(long);             
double lbs(double);

//重载后
int abs(int);
long abs(long);             
double abs(double);
```

**重载解析**:C++用一种函数命名技术可以准确判断应该调用哪个重载函数.

```
abs(10)             //调用int abs(int)
abs(100000000000)   //调用long abs(long)
abs(10.000000000)   //调用double abs(double)
```

## 使用说明

- 返回类型不能单独作为重载解析的依据;参数个数,类型,顺序三者种必须至少有一种不同.
      如:  void func(int);
             int func(int);  //error
- 不能用typedef定义的类型名来区分重载函数声明中的参数.
- 让重载执行不同的功能,是不好的编程风格.

## 例子

```
void print(double);
void print(int); 
void func()
{
	print(1);           //匹配void print(int)
    printf(1.0);       //匹配void print(double)
    print(’a’);         //匹配void print(int)
    print(3.1415f); //匹配void print(double) 
}
```

```
/* ***求3个数中最大的数(分别考虑整数,双精度数,长整数的情况)*** */
#include <iostream>
using namespace std;
int main( )
{	
	int max(int a,int b,int c);                //函数声明
	double max(double a,double b,double c);    //函数声明
	long max(long a,long b,long c);     //函数声明
	int i1,i2,i3,i;                            
	cin>>i1>>i2>>i3;                         //输入3个整数
	i=max(i1,i2,i3);               //求3个整数中的最大者
	cout<<”i_max=”<<i<<endl;
	double d1,d2,d3,d;    
	cin>>d1>>d2>>d3;              //输入3个双精度数
	d=max(d1,d2,d3);       //求3个双精度数中的最大者
	cout<<”d_max=”<<d<<endl;
	long g1,g2,g3,g;
	cin>>g1>>g2>>g3;                //输入3个长整数
	g=max(g1,g2,g3);      //求3个长整数中的最大者
	cout<<”g_max=”<<g<<endl;
}
int max(int a,int b,int c)                //定义求3个整数中的最大者的函数
{
	if(b>a) a=b;
	if(c>a) a=c;
	return a;
}
double max(double a,double b,double c)   //定义求3个双精度数中的最大者的函数
{
	if(b>a) a=b;
    if(c>a) a=c;
    return a;
}
long max(long a,long b,long c)           //定义求3个长整数中的最大者的函数
{
	if(b>a) a=b;
    if(c>a) a=c;
    return a;
}
```

```
/* ***求两个整数或3个整数中的最大数*** */
#include <iostream>
using namespace std;
int main( )
{
	int max(int a,int b,int c);           //函数声明
    int max(int a,int b);                    //函数声明
    int a=8,b=-12,c=27;
    cout<<”max(a,b,c)=”<<max(a,b,c)<<endl;    //输出3个整数中的最大者
    cout<<”max(a,b)=”<<max(a,b)<<endl;       //输出两个整数中的最大者
}
int max(int a,int b,int c)                  //此max函数的作用是求3个整数中的最大者
{
	if(b>a) a=b;
    if(c>a) a=c;
    return a;
}
int max(int a,int b)             //此max函数的作用是求两个整数中的最大者
{
	if(a>b) return a;
    else return b;
}
```

>[info]# 函数模板

- C++提供了**函数模板(function template)**,用以解决函数体完全一样,而函数类型和形参类型不一致的情况.
- 所谓函数模板,实际上是建立一个通用函数,其函数类型和形参类型不具体指定,用一个**虚拟类型**来代表,这个**通用函数**就称为函数模板.
- 在调用函数时系统会根据实参的类型来取代模板中的**虚拟类型**,从而实现了不同函数的功能.
- 用函数模板比函数重载更方便,程序更简洁.但应注意它**只适用**于函数的参数个数相同而类型不同,且函数体相同的情况,如果参数的个数不同,则不能用函数模板.

**定义函数模板的一般形式**

- template <class T>      通用函数定义 
- template < typename T>  通用函数定义
- 类型参数可以不只一个, 根据需要确定个数.   template <class T1,typename T2>

## 例子

```
/* ***求两个整数或3个整数中的最大数*** */
#include <iostream>
using namespace std;
template<typename T>                     //模板声明,其中T为类型参数
T max(T a,T b,T c)                       //定义一个通用函数,用T作虚拟的类型名
{
	if(b>a) a=b;
    if(c>a) a=c;
    return a;
}
int main( )
{
	int i1=185,i2=-76,i3=567,i;
    double d1=56.87,d2=90.23,d3=-3214.78,d;
    long g1=67854,g2=-912456,g3=673456,g;
    i=max(i1,i2,i3);    //调用模板函数,此时T被int取代
    d=max(d1,d2,d3);    //调用模板函数,此时T被double取代
    g=max(g1,g2,g3);    //调用模板函数,此时T被long取代
    cout<<”i_max=”<<i<<endl;
    cout<<”d_max=”<<d<<endl;
    cout<<”g_max=”<<g<<endl;
    return 0;
}
```

>[info]# 作用域

**作用域**是标识符在程序中的有效范围,即可见性区域.

## 作用域类型

局部作用域：局部变量 块语句{}
文件作用域：全局变量
函数作用域
函数原型作用域
类作用域

## 生命期

生命期的**对象**是变量表示符
<br>

 **动态生命期**

对象：普通局部变量

位置：堆区（heap）

初值：不确定值（随机值）

时机：运行时（手动分配）

长短：短

<br>

 **局部生命期**

对象：普通局部变量

位置：栈区（stack）

初值：不确定值（随机值）

时机：编译时

长短：短
<br>

 **静态生命区**

对象：普通全局变量、静态全局变量、静态局部变量

位置：数据区（date）

初值：相应类型的0值

时机：编译之前

长短：长

## 变量

**类型**

- 普通局部变量
- 普通全局变量
- 静态全局变量
- 静态局部变量

**局部变量的生命期**

- 在一个函数内部定义的变量是局部变量,它只在本函数范围内有效;

- 在复合语句中定义的变量也是局部变量,它只在本复合语句范围内有效.


**普通局部变量**

定义时若未赋初值，则该变量的值是不确定的，该不确定值的大小，取决于上一个被分配到该空间的变量的值

该值就是**随机值**

<br>

 **静态局部变量**

其生命周期很长，从被创建开始到程序结束

在一个项目中，一个文件无法从另一个文件中引用静态变量。

<br>

 **例子**

```
//  计算阶乘
#include <iostream>
using namespace std;

long fac(int n)
{
	static long f=1L;     //静态局部变量
	f*=n;
	return f;
}

int main()
{
	for(int i=1;i<=5;i++)
	{
		cout<<i<<"!="<<fac(i)<<endl;
	}
	return 0;
}
```

fac这个函数会被调用多次，每次调用都会分配空间，每次调用结束都会回收空间，所以该函数在程序运行过程中会被分配五次空间，被收回五次空间

<br/>
static long f    
 
f 是静态局部变量，f 被分配的空间在数据区（data）中，该语句只会在第一次运行时调用，每次该函数运行结束，f都会被重新赋值，以此达到计算阶乘的目的。

## 分配空间

编译器为变量**分配空间**的过程就是建立变量名与空间地址的联系。

<br/>
编译器**回收空间**就是断开地址与变量名之间的关系，但是不会回收该空间中的值。
