> # return

1. return在返回值时，假如你得到的值和你定义时的值类型不同，它会自动将你的值转换成你定义时的返回值。
2. 
3. 定义返回值是，如果是void（无返回值），也可以带return，但是不能接数值，直接分号结束，表示这个函数返回。
4. 
5. 如果函数的返回类型为void，函数体中可以有return，但不能带表达式或者值；
6. 如果函数的返回类型不是void，函数体中可以有多个return，但只能执行其中一个。

> # 输入输出的基本操作

本应是按位左移,右移运算符,但在'iostream.h'头文件中被重载为基本数据类型数据的**插入运算符**和**提取运算符**.

cout>表达式1>>...>>表达式n;

一个cout语句可以分写在若干行或多个cout语句;cin类似.

```
cin>>a>>b>>c;
Cout<<a
    <<b
    <<c;
```

不能用一个插入运算符<<插入多个输出项.

```
cout<<a,b,c;    //error
```

在用cin输入时,系统会根据变量的类型从输入流中提取相应长度的字节. 注意:cin语句将跳过空格,回车,换行字符;而在C中将不被跳过,如用函数scanf,getchar.

C++中endl相当于C中的\n起到换行的作用

> # 输入输出流中的控制字符

**头文件：iomainp.h**

| 控制字符                     | 作用               |
| :--------------------------- | :----------------- |
| hex                          | 置基数为16         |
| oct                          | 置基数为8          |
| dec                          | 置基数为10         |
| setfill(c)                   | 填充字符c          |
| setprecision(n)              | 设置显示小数的精度 |
| setw                         | 设置域宽           |
| setiosflags(ios::fixed)      | 固定的浮点显示     |
| setiosflags(ios::scientific) | 指数表示           |
| setiosflags(ios::left)       | 左对齐             |
| setiosflags(ios::right)      | 右对齐             |
| setiosflags(ios::skipws)     | 忽略前导空白       |
| setiosflags(ios::uppercase)  | 16进制数大写输出   |
| setiosflags(ios::lowercase)  | 16进制数小写输出   |

**设置值的输出宽度**

- 除了使用空格来强行控制输出间隔外,还可以使用setw(n)控制符.
- 如果一个值需要比setw(n)确定的字符数更多的字符,则该值将使用它所需要的字符数.
- 如果一个值的字符数比setw(n)确定的字符个数要少,则在数字字符前显示空格.
- setw(n)仅仅影响下一个数值输出.
- setw(n)的默认值为宽度0,即setw(0).

## **例子**

```
/* ******控制字符浮点显示****** */
#include <iostream>
#include <iomanip>  //要用到格式控制符
using namespace std;

int main()
{
	double amount = 22.0/7;
	cout <<amount <<endl;
	cout <<setprecision(0) <<amount <<endl
		 <<setprecision(1) <<amount <<endl
		 <<setprecision(2) <<amount <<endl
		 <<setprecision(3) <<amount <<endl
		 <<setprecision(4) <<amount <<endl;
	cout <<setiosflags(ios::fixed);
    cout <<setprecision(8) <<amount <<endl;
    cout <<setiosflags(ios::scientific)     
    	 <<amount     
    	 <<endl;
      
    cout <<setprecision(6); //重新设置成原默认设置
      
    return 0;
}
/* ******使用填充字符****** */
#include <iostream>
#include <iomanip>
using namespace std; 
int main()
{
	cout <<setfill(’*’)       
		 <<setw(2) <<21 <<endl       
		 <<setw(3) <<21 <<endl       
		 <<setw(4) <<21 <<endl;  
	cout <<setfill(’ ’);  // 恢复默认设置  
	return 0;
}
/* ******左右对齐输出****** */
#include <iostream>
#include <iomanip>
using namespace std;
int main()
{
	cout <<setiosflags(ios::right)
		 <<setw(5) <<1
		 <<setw(5) <<2
		 <<setw(5) <<3 <<endl;
	cout <<setiosflags(ios::left)
		 <<setw(5) <<1
		 <<setw(5) <<2
		 <<setw(5) <<3 <<endl;
	return 0;
}
/* ******强制显示小数点****** */
#include <iostream>
#include <iomanip>
using namespace std; 
int main()
{
	cout <<10.0/5 <<endl;
	cout <<setiosflags(ios::showpoint)
		 <<10.0/5 <<endl;
	return 0;
}
/* ******强制显示符号位****** */
#include <iostream>
#include <iomanip>
using namespace std;
int main()
{  
	cout <<10 <<"  " <<-20 <<endl;  
	cout <<setiosflags(ios::showpos)
		 <<10 <<"  " <<-20 <<endl;
	return 0;
}
/* ******小数点对齐****** */
#include <iostream>
#include <iomanip>
using namespace std;
int main( )
{ 
	double a=123.456,b=3.14159,c=-3214.67; 
	cout<<setiosflags(ios∷fixed)
		<<setiosflags(ios∷right)
		<<setprecision(2);
	cout<<setw(10)<<a<<endl;
	cout<<setw(10)<<b<<endl;
	cout<<setw(10)<<c<<endl;
	return 0;
} 
```

> # putchar和getchar

**(1). putchar函数(字符输出函数)**

函数原型: int putchar(int);

调用格式: putchar(c);

函数功能: 向标准输出设备(一般为显示器)输出一个字符,并返回输出字符的ASCII码值.

函数的参数c可以是字符常量,变量或整型变量.

**(2).getchar函数(字符输入函数)**

函数原型: int getchar(void);

调用格式: getchar( );

函数功能: 从输入设备(一般为键盘)上输入一个字符,函数的返回值是该字符的ASCII码.可以赋给字符变量或整型变量.

> # 用const定义常变量

在定义变量时,如果加上关键字const,则变量的值在程序运行期间不能改变,这种变量称为常变量(constant variable).
如 const int pi=3.1415926;
常量在定义时必须初始化,常量名不能放在赋值号的左边.
可以用常量表达式对常量进行初始化.

## 符号常量(#define)与const常量的区别

1. \#define宏是在预处理阶段展开。
   const常量是编译运行阶段使用。

2. \#define宏没有类型，不做任何类型检查，仅仅是展开。
   const常量有具体的类型，在编译阶段会执行类型检查。

3. \#define宏仅仅是展开，有多少地方使用，就展开多少次，不会分配内存(宏定义不分配内存，**变量定义**分配内存。）
   const常量会在内存中分配(可以是堆中也可以是栈中)。

4. const常量可以进行调试的

   \#define是不能进行调试的，因为在预编译阶段就已经替换掉了

5. const不足的地方，是与生俱来的，const不能重定义

   \#define可以通过#undef取消某个符号的定义，再重新定义。